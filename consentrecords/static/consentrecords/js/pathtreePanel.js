/* showPathtree.js */

var PathOverlap = (function() {
	PathOverlap.prototype.r1 = null;
	PathOverlap.prototype.r2 = null;
	PathOverlap.prototype.y = 0.0;
	
	PathOverlap.prototype.intersects = function(other)
	{
		return (Math.min(this.bottom,other.bottom) - Math.max(this.top,other.top)) > 0;
	}
	
	function PathOverlap(i, j)
	{
		this.r1 = i;
		this.r2 = j;
		this.top = Math.max(i.y,j.y);
		this.bottom = Math.max(0, Math.min(i.y + i.height,j.y + j.height));
	}
	
	return PathOverlap;
})();

var PathSpring = (function() {
	PathSpring.prototype.left = null;
	PathSpring.prototype.right = null;
	PathSpring.prototype.e = 0.0;
	
	PathSpring.prototype.flagSpacing = 5;
	PathSpring.prototype.overlapTerm = 16;
	PathSpring.prototype.marginTerm = 4;
	PathSpring.prototype.expandedTerm = 1;	/* For springs that are larger than maxSpacing */
	PathSpring.prototype.maxEnergy = 99999999;
	
	PathSpring.prototype.getEnergy = function()
	{
		var d = this.right.x - (this.left.x + this.left.width);
		if (d < 0)	/* Overlap */
		{
			var minWidth = this.left.width - 12;
			var t = 100 - ((minWidth + d) / minWidth * 100);
			return (t * t * this.overlapTerm) + (this.flagSpacing * this.flagSpacing * this.marginTerm);
		}
		else if (d < this.flagSpacing)
		{
			d -= this.flagSpacing;
			return d * d * this.marginTerm + this.expandedTerm;	
				/* Add this.expandedTerm so that any amount less than flagSpacing has a greater energy
					than the energy in the first unit greater than flagSpacing */
		}
		else
		{
			d -= this.flagSpacing;
			return d * d * this.expandedTerm;
		}
	}
	
	PathSpring.prototype.setEnergy = function()
	{
		this.e = this.getEnergy();
	}
	
	function PathSpring(left, right)
	{
		this.left = left;
		this.right = right;
	}
	
	return PathSpring;
})();

var FlagData = (function() {
	FlagData.prototype.experience = null;
	FlagData.prototype.x = null;
	FlagData.prototype.y = null;
	FlagData.prototype.height = null;
	FlagData.prototype.width = null;
	FlagData.prototype.springs = null;
	
	FlagData.prototype.flagSpacing = 5;
	FlagData.prototype.maxEnergy = 99999999;
	FlagData.prototype.widthStretchedTerm = 100;
	FlagData.prototype.widthCompressedTerm = 37; /* (5 * 5 - 4 * 4) * PathSpring.marginTerm + 1 */

	FlagData.prototype.getDescription = function()
	{
		var d = this.experience.getValue("Offering");
		if (d && d.getValueID())
			return d.getDescription();
		var s = this.experience.getDatum("User Entered Offering");
		if (s && s.length)
			return s;
		d = this.experience.getValue("Service");
		if (d && d.getValueID())
			return d.getDescription();
		s = this.experience.getDatum("User Entered Service");
		if (s && s.length)
			return s;
		return "None";
	}
	
	FlagData.prototype.pickedOrCreatedValue = function(pickedName, createdName)
	{
		return getPickedOrCreatedValue(this.experience, pickedName, createdName);
	}
	
	/* Returns the energy that attracts this object to its adjacent objects. */
	FlagData.prototype.getCachedSpringEnergy = function()
	{
		return this.springs.map(function(s) { return s.e; })
			.reduce(function(a, b) { return a + b; }, 0.0);
	}
	
	/* Returns the energy that attracts this object to its walls or screen edges. */
	FlagData.prototype.getCurrentSpringEnergy = function()
	{
		return this.springs.map(function(s) { return s.getEnergy(); })
			.reduce(function(a, b) { return a + b; }, 0.0);
	}
	
	/* Returns the energy that is generated by compressing the width of this item such that its text doesn't all appear. */
	FlagData.prototype.getWidthEnergy = function()
	{
		var d = this.width - this.bestWidth;
		if (d > 0)
			return (d * d * this.widthStretchedTerm);
		else
			return d * d * this.widthCompressedTerm;
	}
	
	/* Returns massive amounts of energy if this item falls outside the display area. */
	FlagData.prototype.getXBoundEnergy = function(maxX)
	{
		if (this.x < 0)
			return this.maxEnergy;
		else if (this.x + this.width > maxX)
		{
			var d = maxX - (this.x + this.width);
			var t = d / this.width * 100;	/* Normalize to a range from 0 to 100. */
			return t * t * PathSpring.prototype.overlapTerm + (this.flagSpacing * this.flagSpacing * PathSpring.prototype.marginTerm);
		}
		else if (this.x + this.width > maxX - this.flagSpacing)
		{
			var d = maxX - this.flagSpacing - (this.x + this.width);
			return d * d * PathSpring.prototype.marginTerm;
		}
		else
			return 0;
	}
	
	FlagData.prototype.cacheFlagEnergy = function(rightEdge)
	{
		this.flagEnergy = this.getWidthEnergy() + this.getXBoundEnergy(rightEdge);
	}
	
	FlagData.prototype.setEnergy = function(rightEdge)
	{
		this.springs.forEach(function(s) { s.setEnergy(); });
		this.cacheFlagEnergy(rightEdge);
	}
	
	FlagData.prototype.getCachedEnergy = function()
	{
		return this.getCachedSpringEnergy() + this.flagEnergy;
	}
	
	FlagData.prototype.getCurrentEnergy = function(rightEdge)
	{
		return this.getWidthEnergy() + this.getXBoundEnergy(rightEdge) +
			this.getCurrentSpringEnergy();
	}
	
	FlagData.prototype.incrementX = function(dx)
	{
		this.x += dx;
	}
	
	FlagData.prototype.incrementWidth = function(dx)
	{
		this.width += dx;
	}
	
	FlagData.prototype.incrementLeft = function(dx)
	{
		/* Keep the right edge the same, but move the left edge. */
		this.x += dx;
		this.width -= dx;
	}
	
	/* Get the change in energy of fi when the value of the specified field changes by dx. */
	FlagData.prototype.getDelta = function(f, dx, rightEdge)
	{
		f.call(this, dx);
		
		var delta = this.getCurrentEnergy(rightEdge) - this.getCachedEnergy();
		
		f.call(this, -dx);
		
		return delta;
	}
	
	FlagData.prototype.rightSprings = function()
	{
		var _this = this;
		return this.springs.filter(function(s) { return s.left == _this; });
	}
	
	FlagData.prototype.leftSprings = function()
	{
		var _this = this;
		return this.springs.filter(function(s) { return s.right == _this; });
	}
	
	FlagData.prototype.setSpanWidth = function(rightEdge)
	{
		var maxRightSpan = this.rightSprings()
			.map(function(s) {
				if (s.right.isFixed)
					return rightEdge - s.right.x;
				else
					return s.right.spanWidth;
				})
			.reduce(function(a, b) { return Math.max(a, b); }, 0.0);
		this.spanWidth = this.width + (maxRightSpan === 0.0 ? 0.0 : maxRightSpan + this.flagSpacing);
	}
	
	function FlagData(experience)
	{
		this.experience = experience;
		this.y = null;
		this.x = null;
		this.height = null;
		this.width = null;
	}
	return FlagData;
})();

var Pathtree = (function () {
	Pathtree.prototype.dataTopMargin = 5;
	Pathtree.prototype.dataBottomMargin = 5;
	Pathtree.prototype.dataLeftMargin = 40;			/* The space between the left margin and the beginning of the flags */
	Pathtree.prototype.textLeftMargin = 3;
	Pathtree.prototype.textRightMargin = 3;
	Pathtree.prototype.textBottomBorder = 3;
	Pathtree.prototype.flagsLeftMargin = 14;
	Pathtree.prototype.flagsRightMargin = 14;
	Pathtree.prototype.flagSpacing = 5;
	Pathtree.prototype.stemHeight = 3;
	Pathtree.prototype.otherColor = "#bbbbbb";
	Pathtree.prototype.textDetailLeftMargin = 10; /* textLeftMargin; */
	Pathtree.prototype.textDetailRightMargin = 10; /* textRightMargin; */
	Pathtree.prototype.detailTextSpacing = 2;		/* The space between lines of text in the detail box. */
	Pathtree.prototype.pathBackground = "white";
	Pathtree.prototype.showDetailIconWidth = 18;
	
	Pathtree.prototype.user = null;
	Pathtree.prototype.allExperiences = [];
	Pathtree.prototype.sitePanel = null;
	Pathtree.prototype.containerDiv = null;
	Pathtree.prototype.pathwayContainer = null;
	Pathtree.prototype.timeContainer = null;
	Pathtree.prototype.svg = null;
	Pathtree.prototype.svgTime = null;
	Pathtree.prototype.loadingMessage = null;
	Pathtree.prototype.defs = null;
	Pathtree.prototype.bg = null;
	Pathtree.prototype.bgTime = null;
	Pathtree.prototype.loadingText = null;
	Pathtree.prototype.promptAddText = null;
	Pathtree.prototype.experienceGroup = null;
	Pathtree.prototype.yearGroup = null;
	Pathtree.prototype.detailGroup = null;
	Pathtree.prototype.detailBackRect = null;
	Pathtree.prototype.detailFrontRect = null;
	
	Pathtree.prototype.detailFlagData = null;
	Pathtree.prototype.flagElement = null;
	Pathtree.prototype.flagHeight = 0;
	Pathtree.prototype.flagWidth = 0;
	
	Pathtree.prototype.minDate = null;
	Pathtree.prototype.maxDate = null;
	Pathtree.prototype.timespan = 0;
	Pathtree.prototype.isLayoutDirty = true;
	Pathtree.prototype.isMinHeight = false;
	Pathtree.prototype.dayHeight = 0;
	Pathtree.prototype.years = [];
	
	Pathtree.prototype.nextClipID = 1;
	Pathtree.prototype.clipID = null;
	
	//This is the accessor function we talked about above
	Pathtree.prototype._lineFunction = d3.svg.line()
		.x(function(d) { return d.x; })
		.y(function(d) { return d.y; })
		.interpolate("linear");

	Pathtree.prototype.getService = function(experience)
	{
		var offering = experience.getValue("Offering");
		if (offering && offering.getValueID())
		{
			var service = offering.getValue("Service");
			if (service)
				return service;
		}
		return experience.getValue("Service");
	}
	
	Pathtree.prototype.getServiceDomain = function(experience)
	{
		var service = this.getService(experience);
		return service && crp.getInstance(service.getValueID()).getValue("Service Domain")
	}

	Pathtree.prototype._compareExperiences = function(a, b, ordered)
	{
		var aServiceDomain = this.getServiceDomain(a);
		var bServiceDomain = this.getServiceDomain(b);
		if (!bServiceDomain)
		{
			if (aServiceDomain) return -1;
		}
		else if (!aServiceDomain)
			return 1;
		else
		{
			var aDescription = aServiceDomain.getDescription();
			var bDescription = bServiceDomain.getDescription();
			var aOrder = ordered.indexOf(aDescription);
			var bOrder = ordered.indexOf(bDescription);
			if (aOrder < 0) 
			{
				ordered.push(aDescription);
				aOrder = ordered.length;
			}
			if (bOrder < 0)
			{
				ordered.push(bDescription);
				bOrder = ordered.length;
			}
			if (aOrder != bOrder)
				return aOrder - bOrder;
		}
		
		var aStartDate = getStartDate(a);
		var bStartDate = getStartDate(b);
		if (aStartDate > bStartDate) return 1;
		else if (aStartDate < bStartDate) return -1;
		else
		{
			var aEndDate = getEndDate(a);
			var bEndDate = getEndDate(b);
			if (aEndDate > bEndDate) return 1;
			else if (aEndDate < bEndDate) return -1;
			else return 0;
		}
		return aStartDate - bStartDate;
	}

	Pathtree.prototype.DateToY = function(d)
	{
		var daySpan = (new TimeSpan(d-this.minDate)).days;
		return this.dataTopMargin + (this.timespan - daySpan) * this.dayHeight;
	}

	Pathtree.prototype.getExperienceY = function(fd)
	{
		return this.DateToY(Date.parse(getEndDate(fd.experience)));
	}

	Pathtree.prototype.getExperienceHeight = function(experience)
	{
		var startDate = getStartDate(experience);
		var endDate = getEndDate(experience);
		var days = (new TimeSpan(Date.parse(endDate)-Date.parse(startDate))).days;
		return days * this.dayHeight;
	}

	Pathtree.prototype.getExperiencePath = function(g, fd)
	{
		var h = fd.height;
		var x1 = 0;
		var x2 = x1 + fd.width;
		var y1 = 0;
		var y4 = y1 + h;
		return this._lineFunction([{x: x1, y: y1}, 
							 {x: x2, y: y1}, 
							 {x: x2, y: y4}, 
							 {x: x1, y: y4}, 
							 {x: x1, y: y1}]);
	}
	
	Pathtree.prototype.clearLayout = function()
	{
		/* Do whatever it takes to force layout when checkLayout is called. */
		this.isLayoutDirty = true;
	}
	
	Pathtree.prototype.truncatedText = function(text, textNode, maxWidth)
	{
		var t = d3.select(textNode);
		t.text(text);
		if (text.length <= 1)
			return;
		else if (textNode.getBBox().width <= maxWidth)
			return;
		
		var testText = text.slice(0, -1);
		while (testText.length > 0)
		{
			t.text(testText + "...");
			if (textNode.getBBox().width <= maxWidth)
				return;
			testText = testText.slice(0, -1);
		}
		t.text("...");
	}
	
	Pathtree.prototype.scaleDayHeightToSize = function()
	{
		var containerHeight = $(this.svg.node()).height();
		var dataHeight = containerHeight - this.dataTopMargin - this.dataBottomMargin;
		var oldDayHeight = this.dayHeight;
		this.dayHeight = dataHeight / this.timespan;
		return oldDayHeight != this.dayHeight;
	}
	
	Pathtree.prototype.bestDeltaF = function(f, delta)
	{
		return function(previous, current, index)
		{
			if (current < previous.e)
				return {e: current, delta: delta, index: index, f: f};
			else
				return previous;
		}
	}
	
	Pathtree.prototype.iterate = function(fds, delta, rightEdge)
	{
		var best = {e: 0.0, delta: 0.0, index: -1};
		
		var _this = this;
		[FlagData.prototype.incrementX,
		 FlagData.prototype.incrementWidth,
		 FlagData.prototype.incrementLeft].forEach(function(f)
			{
				best = fds.map(function(fi) { return fi.getDelta(f, delta, rightEdge); })
					.reduce(_this.bestDeltaF(f, delta), best);
				best = fds.map(function(fi) { return fi.getDelta(f, -delta, rightEdge); })
					.reduce(_this.bestDeltaF(f, -delta), best);
			});
			
		if (best.e < -0.01)
		{
			var fi = fds[best.index];
			best.f.call(fi, best.delta);
			fi.setEnergy(rightEdge);
			
			return best;
		}
		else
			return false;
	}
	
	Pathtree.prototype.drawExperiences = function(g)
	{
		var _this = this;
		g.attr("transform", 
			function(fd)
			{
				return "translate(" + fd.x + "," + fd.y + ")";
			})
			
		if (g.size() > 0)
		{
			/* Transform each text node relative to its containing group. */
			g.selectAll('text')
				.each(function(fd) { _this.truncatedText(fd.getDescription(), this, 
						Math.max(fd.width - _this.textLeftMargin - _this.textRightMargin, 0)); });
			
			/* Calculate the path for each containing group. */
			g.selectAll('rect')
				.attr("width", function(fd) { return fd.width; } )
				.attr("height", function(fd) { return fd.height; });
			g.selectAll('line')
				.attr('y2', function(fd) { return fd.height; });
		}

		/* Hide the detail so that if detail is visible before a resize, it isn't left behind. */	
		if (this.detailFlagData != null)
		{
			this.refreshDetail();
		}
	}
	
	Pathtree.prototype.drawSprings = function(lines)
	{
		var _this = this;
		lines.attr('x1', function(d) { return d.left.x + d.left.width; })
			.attr('y1', function(d) { return d.left.y + d.left.height / 2; })
			.attr('x2', function(d) { return d.right.x; })
			.attr('y2', function(d) { return d.right.y + d.right.height / 2; })
			.attr('stroke-width', 2)
			.attr('stroke', '#222222');
	}
	
	Pathtree.prototype.getSprings = function(fds)
	{
		fds.forEach(function(fd, index) { fd.springs = []; fd.overlaps = []; fd.index = index;});

		fds.sort(function(a, b) {
			if (a.y != b.y)
				return a.y - b.y;
			if (a.height != b.height)
				return b.height - a.height;
			if (a.column != b.column)
				return b.column - a.column;
			return b.index - a.index;
			});
			
		/* Create a spring between each pair of items whose y values overlap, but there isn't an item
			that overlaps both of them with an x value between them.
		 */
		
		/* First, create the overlaps for each experience. 
			For each experience (fi), an overlap is created for experiences that are after it and 
			whose y coordinate is less than this item plus its height. The overlap is associated with
			the experience (fi or fj) that has the minimum x-coordinate.
		 */
		fds.forEach(function(fi, index)
			{
				var maxY = fi.y + fi.height;
				for (var j = index + 1; j < fds.length && fds[j].y < maxY; ++j)
				{
					var fj = fds[j];
					if (fj.x > fi.x)
					{
						fi.overlaps.push(new PathOverlap(fi, fj));
					}
					else
					{
						fj.overlaps.push(new PathOverlap(fj, fi));
					}
				}
			});
		
		/* Sort the overlaps by their x coordinate, filter for only overlaps that
			don't intersect with other overlaps and create springs for each such overlap.
			
			return the total list of springs.
		 */
		return fds.map(function(fi)
			{
				var s = fi.overlaps
					.sort(function(a, b) { return a.r2.x - b.r2.x; })
					.filter(function(overlapJ, jIndex)
						{
							for (var k = 0; k < jIndex; ++k)
							{
								if (overlapJ.intersects(fi.overlaps[k]))
									return false;
							}
							return true;
						})
					.map(function(overlapJ) { return new PathSpring(fi, overlapJ.r2); });
					
				/* Add each spring to its left and right edge. */
				s.forEach(function (spring) {
					spring.left.springs.push(spring);
					spring.right.springs.push(spring);
				});
				return s;
			})
			.reduce(function(a, b) { return a.concat(b); }, []);
	}
	
	Pathtree.prototype.setSprings = function(fds)
	{
		var springs = this.getSprings(fds);
		springs.forEach(function(s) { s.setEnergy(); });
		return springs;
	}
	
	Pathtree.prototype.draw = function(g)
	{
		this.drawExperiences(g);
	}
	
	/* Optimize the positions of the flags so that they overlap as little as possible
		and as much of their text is visible.
		
		This method uses an iterative minimization that finds the highest energy change
		from changing the x or width values of an item and iterates with smaller and
		smaller increments (32 down to 1) until there isn't a substantive change.
		
		Brute force, but fast enough, so far.
	 */
	Pathtree.prototype.optimize = function(g)
	{
		var fds = g.data();
		var springs = this.setSprings(fds);
				
		var _this = this;
		var rightEdge = $(this.svg.node()).width();
		fds.forEach(function(fi) { 
			fi.cacheFlagEnergy(rightEdge);
		});
		
		var delta = 32;
		while (delta >= 1)
		{
			while (this.iterate(fds, delta, rightEdge))
			{
				continue;
			}
			delta /= 2;
		}
		
		/* Recompute the springs to ensure that newly separated items don't overlap. */
		springs = this.setSprings(fds);
				
		/* Set the spanWidth of every item leftover to the width of the span from it to the right */
		fds.forEach(function(fi) { fi.isFixed = (fi.width < fi.bestWidth); });
		var items = fds.filter(function(fi) { return !fi.isFixed; });
		fds.forEach(function(fi) { fi.spanWidth = 0.0; });
		
		/* For any item to the right of a compressed item, don't shift those items. */
		var cQueue = items.filter(function(fi)
			{
				return fi.leftSprings().filter(function(s) { return s.left.isFixed; }).length > 0;
			});
		while (cQueue.length > 0)
		{
			var fi = cQueue.shift();
			fi.isFixed = true;
			var index = items.indexOf(fi);
			if (index >= 0)
			{
				items.splice(index, 1);
				fi.rightSprings().forEach(function(s)
					{
						cQueue.push(s.right);
					});
			}
		}
		
		while (items.length > 0)
		{
			/* For every item in the list that has no lines to the right that are in the list, 
				add its width + flagSpacing to all of its items on the left 
				and remove it from the list. */
			var rightItems = items.filter(function(fi) {
				return fi.springs.filter(function(s) { return s.left == fi && 
															  s.right.spanWidth == 0.0 &&
															  !s.right.isFixed; }) == 0; });
			
			/* Pick a rightItem at random and set its spanWidth */												  
			var fi = rightItems[0];
			fi.setSpanWidth(rightEdge);
			items.splice(items.indexOf(fi), 1);
			
			/* using a queue, build up a list of items that have common lefts. */
			var lQueue = [fi];
			var lItems = [fi];
			while (lQueue.length > 0)
			{
				var qi = lQueue.shift();
				qi.leftSprings()
					.forEach(function(s) { 
						var qj = s.left;
						qj.rightSprings().forEach(function(s) {
							var qk = s.right;
							if (lItems.indexOf(qk) < 0 && qk.spanWidth > 0)
							{
								lItems.push(qk);
								lQueue.push(qk);
							}
						})
					});
			}
			
			if (lItems.length > 1)	/* Do nothing for the degenerate case of 1 item */
			{
				/* Otherwise, get the maximum span width of all of the items with common lefts,
					and, for each one, increment its spanWidth so that it is also the maximum.
					For each item that is incremented, re-calculcate any items to the left of it that 
					has already been set.
				 */
				var maxSpanWidth = lItems.reduce(function(a, b) { return Math.max(a, b.spanWidth); }, 0.0);
				lItems.forEach(function(fj)
					{
						if (fj.spanWidth < maxSpanWidth)
						{
							fj.spanWidth = maxSpanWidth;
							var mQueue = [fj];
							while (mQueue.length > 0)
							{
								var qi = mQueue.shift();
								qi.leftSprings().forEach(function(s) 
									{
										var qj = s.left;
										if (qj.spanWidth > 0)
										{
											var oldSpanWidth = qj.spanWidth;
											qj.setSpanWidth(rightEdge);
											if (oldSpanWidth < qj.spanWidth)
												mQueue.push(qj);
										}
									});
							}
						}
					});
			}
		}
		
		/* Make a list of every item */
		items = fds.filter(function(fi) { return !fi.isFixed; });
		items.sort(function(a, b) { return b.spanWidth - a.spanWidth; });
		
		/* If all of the items are variable length, then limit the right edge to the
			maximum width (forcing all items left).
		 */
		if (items.length == fds.length && items.length > 0)
			rightEdge = items[0].spanWidth;
		
		/* Now place all of the items */
		while (items.length > 0)
		{
			/* Find the item with the largest width. */
			var fi = items.shift();
			
			/* If it is to the right of a fixed item, then place it there, otherwise
				place it so that its maxSpan is centered from 0 to rightEdge. */
			var maxLeft = fi.leftSprings()
				.map(function(s) {
					if (s.left.isFixed)
						return s.left.x + s.left.width;
					else
						return 0.0;
					})
				.reduce(function(a, b) { return Math.max(a, b); }, 0.0);
			var leftEdge = maxLeft > 0.0 ? maxLeft + fi.flagSpacing : 0.0;
			fi.x = leftEdge + (rightEdge - leftEdge - fi.spanWidth) / 2;
			
			/* Place items that aren't already placed relative to this item. */
			var queue = [fi];
			while (queue.length > 0)
			{
				fi = queue.shift();
				fi.springs.filter(function(s) { 
						return !s.right.isFixed &&
							   s.left == fi &&
							   items.indexOf(s.right) >= 0;
					})
					.forEach(function(s) {
						var fj = s.right;
						fj.x = fi.x + fi.width + fi.flagSpacing;
						queue.push(fj);
						items.splice(items.indexOf(fj), 1);
					});
				fi.springs.filter(function(s) { 
						return !s.left.isFixed &&
							   s.right == fi &&
							   items.indexOf(s.left) >= 0;
					})
					.forEach(function(s) {
						var fj = s.left;
						fj.x = fi.x - fi.flagSpacing - fj.width;
						queue.push(fj);
						items.splice(items.indexOf(fj), 1);
					});
			}
		}
		
		this.draw(g);
	}
	
	/* Lay out all of the contents within the svg object. */
	Pathtree.prototype.layout = function()
	{
		var svgHeight = $(this.svg.node()).height();
		
		this.isMinHeight = (svgHeight == $(this.containerDiv).height());
		$(this.bg.node()).height(svgHeight);
		$(this.bg.node()).width($(this.svg.node()).width());
		$(this.bgTime.node()).height(svgHeight);
		
		this.sitePanel.contractButton
			.classed('disabled', svgHeight <= $(this.containerDiv).height())
			.classed('enabled', svgHeight > $(this.containerDiv).height());
	
		var g = this.experienceGroup.selectAll('g');
		var y = this.yearGroup.selectAll('text');
		
		var _thisPathway = this;
		
		var ordered = ["Housing", "Education", "Extra Curricular", "Wellness", "Career & Finance", "Helping Out"];
		
		/* Restore the sort order to startDate/endDate */
		g.sort(function(a, b)
		{
			return _thisPathway._compareExperiences(a.experience, b.experience, ordered);
		});
	
		var columns = ordered.map(function(d) { return []; }).concat([[]]);

		/* MaxHeight is the maximum height of the top of a column before skipping to the
			next column.
			this represents the SVG group being added. */
		function addToBestColumn(fd, columns)
		{
			var sd = _thisPathway.getServiceDomain(fd.experience);
			if (sd)
			{
				var i = ordered.indexOf(sd.getDescription());
				if (i < 0)
					columns[ordered.length].push(this);
				else
					columns[i].push(this);
			}
			else
				columns[ordered.length].push(this);
		}
		
		/* Compute the y attribute for every item */
		
		/* Reset the text for each object, in case it was previously squashed. */
		g.selectAll('text').text(function(d) { return d.getDescription(); });
		
		/* Fit each item to a column, according to the best layout. */	
		g.each(function(fd, i)
			{
				fd.y = _thisPathway.getExperienceY(fd);
				fd.height = _thisPathway.getExperienceHeight(fd.experience);
				var textNode = d3.select(this).selectAll('text').node();
				if (fd.height < _thisPathway.flagHeight)
				{
					$(textNode).css('font-size', '10px');
					if (fd.height < _thisPathway.smallFlagHeight)
						fd.height = _thisPathway.smallFlagHeight;
					$(textNode).attr('y', 0 - _thisPathway.smallFlagY);
				}
				else
				{
					$(textNode).css('font-size', '');
					$(textNode).attr('y', 0 - _thisPathway.flagY);
				}
				
				fd.width = textNode.getBBox().width + 
							_thisPathway.textLeftMargin + _thisPathway.textRightMargin;
				fd.bestWidth = fd.width;
				fd.bestY = fd.y;
				addToBestColumn.call(this, fd, columns);
			});
		
		/* Compute the column width for each column of flags + spacing to its right. 
			Add flagSpacing before dividing so that the rightmost column doesn't need spacing to its right.
		 */
	
		var flagColumnWidth = ($(this.svg.node()).width() - this.flagsRightMargin + this.flagSpacing) / columns.length;
		this.flagWidth = flagColumnWidth - this.flagSpacing;
		
		/* Compute the x attribute for every item */
		/* Then, Add the items to the flag columns in the column order for better results than
			the current sort order.
		 */
		for (var j = 0; j < columns.length; ++j)
		{
			var x = (flagColumnWidth * j);
			var column = columns[j];
			var tops = new Array(column.length);
			for (var i = 0; i < column.length; ++i)
			{
				var fd = d3.select(column[i]).datum();
				for (var k = 0; k <= i; ++k)
				{
					if (!tops[k] || tops[k].y >= fd.y + fd.height)
					{
						tops[k] = fd;
						fd.x = x + (k * 2);
						break;
					}
				}
				
				fd.column = j;
			}
		}
		
		if (this.detailFlagData != null)
		{
			/*( Restore the flagElement */
			 g.each(function(fd)
			 {
				if (fd === _thisPathway.detailFlagData)
					_thisPathway.flagElement = this;
			 });
		}
		
		y.attr("y", function(d) { 
				return _thisPathway.DateToY(new Date(d, 0, 0));
			});
			
		if (y.size() >= 2)
		{
			var oldD0 = y[0][0];
			var thisHeight = oldD0.getBBox().height;
			var spacing = 365 * this.dayHeight;
			
			var yearPeriod = parseInt(thisHeight / spacing) + 1;
			if (yearPeriod == 1)
				y.attr("display", null);
			else
			{
				// Set the target so that the latest year is always visible.
				var target = (y.size() - 1) % yearPeriod;
				y.attr("display", function(d, i) { if (i % yearPeriod == target) return null; else return "none";});
			}
		}
		
		this.defs.selectAll('clipPath').remove();
		
		/* Add a clipPath for the text box size. */
		this.defs.append('clipPath')
			.attr('id', 'id_detailClipPath{0}'.format(this.clipID))
			.append('rect');
		this.defs.append('clipPath')
			.attr('id', 'id_detailIconClipPath{0}'.format(this.clipID))
			.append('rect');

		/* Here optimize the positions of all of the fd's. */
		/*
			t1 is the area of overlap between two rectangles.
			t2 is the area of an object outside the bounds of the display area.
			t3 is the square of the distance from a fixed edge.
			t4 is the square of the cut-off of the text.
			t5 is the square of the distance of the time middle from the rectangle's middle.
			
			v1 = x
			v2 = y
			v3 = width
		 */
	
		this.optimize(g);
	}

	Pathtree.prototype.checkLayout = function()
	{
		if ($(this.containerDiv).width() === 0)
			return;
		
		if (!this.isLayoutDirty)
			return;
		
		/* Calculate the height of the area where data appears and the height of a single day. */
		var dataHeight = this.dayHeight * this.timespan;
		var svgHeight = dataHeight + this.dataTopMargin + this.dataBottomMargin;
		var containerHeight = $(this.containerDiv).height();
		var containerWidth = $(this.containerDiv).width();

		$(this.svg.node()).height(svgHeight);
		$(this.svgTime.node()).height(svgHeight);
		
		this.layout();
		this.isLayoutDirty = false;
	}
	
	Pathtree.prototype.scale = function(multiple, done)
	{
		var newDataHeight = this.dayHeight * multiple * this.timespan;
		var newContainerHeight = Math.max(newDataHeight + this.dataTopMargin + this.dataBottomMargin, 
										  $(this.containerDiv).height());
										  
		var _this = this;
		$(this.svg.node()).animate({height: newContainerHeight},
		   {duration: 400, easing: "swing",
			progress: function(animation, progress, remainingMs)
				{
					var containerNode = _this.pathwayContainer.node();
					var newContainerHeight = $(_this.svg.node()).height();
					var newContainerWidth = Math.max($(containerNode).width(),
													 newContainerHeight * $(_this.containerDiv).width() / $(_this.containerDiv).height()
														- _this.dataLeftMargin);
					var oldCenter = containerNode.scrollTop + $(containerNode).height() / 2;
					var oldDayHeight = _this.dayHeight;
					$(_this.svg.node()).width(newContainerWidth);
					$(_this.svgTime.node()).height(newContainerHeight);
					if (_this.scaleDayHeightToSize())
					{
						_this.layout();
						var newCenter = (oldCenter - _this.dataTopMargin) * (_this.dayHeight / oldDayHeight) + _this.dataTopMargin;
						if (containerNode.scrollTop > 0)
						{
							containerNode.scrollTop += newCenter - oldCenter;
							_this.timeContainer.node().scrollTop = containerNode.scrollTop;
						}
					}
				},
			 complete: done
			});
	}
	
	Pathtree.prototype.setDateRange = function()
	{
		var birthday = this.user.getValue("Birthday");
		if (birthday && birthday.text)
			this.minDate = new Date(birthday.text);
		else
			this.minDate = new Date();
		
		this.maxDate = new Date();
		var _this = this;
		$(this.allExperiences).each(function()
			{
				var startDate = new Date(getStartDate(this));
				var endDate = new Date(getEndDate(this));
				if (_this.minDate > startDate)
					_this.minDate = startDate;
				if (_this.maxDate < endDate)
					_this.maxDate = endDate;
			});
			
		/* Make the timespan start on Jan. 1 of that year. */
		this.minDate.setUTCMonth(0);
		this.minDate.setUTCDate(1);
		
		if (this.maxDate < this.minDate)
		{
			/* Make sure that the maxDate is at least 365 days after the minDate, but no later than today. */
			this.maxDate = (new Date(this.minDate)).addDays(365);
			if (this.maxDate > new Date())
				this.maxDate = new Date();
		}
		
		/* Now make sure that the minimum date is at least a year before the maximum date. */
		var maxMinDate = (new Date(this.maxDate)).addDays(-365);
		if (this.minDate > maxMinDate)
			this.minDate = maxMinDate;
	
		this.timespan = new TimeSpan(this.maxDate - this.minDate).days;

		var minYear = this.minDate.getUTCFullYear();
		var maxYear = this.maxDate.getUTCFullYear();
		this.years = [];
		for (var y = minYear; y <= maxYear; ++y)
			this.years.push(y);

		/* create the set of text objects for each year. */
		this.yearGroup.selectAll('text').remove();
		this.yearGroup
			.selectAll('text')
			.data(this.years)
			.enter()
			.append('text')
			.text(function(d) { return d; })
			.attr("font", "sans-serif")
			.attr("font-size", "10px")
			.attr("x", this.textLeftMargin);
;
	}
	
	Pathtree.prototype.checkDateRange = function(experience)
	{
		var oldMinDate = this.minDate;
		var oldMaxDate = this.maxDate;
		var oldMinYear = this.minDate.getUTCFullYear();	
		var oldMaxYear = this.maxDate.getUTCFullYear();	
		
		var startDate = new Date(getStartDate(experience));
		var endDate = new Date(getEndDate(experience));
		if (this.minDate > startDate)
			this.minDate = startDate;
		if (this.maxDate < endDate)
			this.maxDate = endDate;
		
		/* Make the timespan start on Jan. 1 of that year. */
		this.minDate.setUTCMonth(0);
		this.minDate.setUTCDate(1);
		
		var minYear = this.minDate.getUTCFullYear();
		var maxYear = this.maxDate.getUTCFullYear();
		
		this.timespan = new TimeSpan(this.maxDate - this.minDate).days;
		if (minYear < oldMinYear || maxYear > oldMaxYear)
		{
			this.years = [];
			for (var y = minYear; y <= maxYear; ++y)
				this.years.push(y);

			/* create the set of text objects for each year. */
			this.yearGroup.selectAll('text').remove();
			this.yearGroup
				.selectAll('text')
				.data(this.years)
				.enter()
				.append('text')
				.text(function(d) { return d; })
				.attr("font", "sans-serif")
				.attr("font-size", "10px")
				.attr("x", this.textLeftMargin);
		}
			
		return this.minDate < oldMinDate || this.maxDate > oldMaxDate;
	}
	
	Pathtree.prototype.setColorByService = function(service)
	{
		var serviceInstance = crp.getInstance(service.getValueID());
		var serviceDomain = serviceInstance && serviceInstance.getValue("Service Domain");
		if (serviceDomain && serviceDomain.getValueID())
		{
			var sdInstance = crp.getInstance(serviceDomain.getValueID());
			color = sdInstance.getValue("Color");
			if (color && color.text)
				this.attr("fill", color.text)
					 .attr("stroke", color.text);
		}
		else
			this.attr("fill", otherColor)
				.attr("stroke", otherColor);
	}

	Pathtree.prototype.setColor = function(fd)
	{
		var _this = d3.select(this);

		var offering = fd.experience.getValue("Offering");
		if (offering && offering.getValueID())
		{
			var experienceColor = otherColor;
			var service = offering.getValue("Service");
			if (service)
				Pathtree.prototype.setColorByService.call(_this, service);
			else
				_this.attr("fill", otherColor)
					 .attr("stroke", otherColor);
		}
		else
		{
			var service = fd.experience.getValue("Service");
			if (service && service.getValueID())
				Pathtree.prototype.setColorByService.call(_this, service);
			else
				_this.attr("fill", otherColor)
					 .attr("stroke", otherColor);
		}
	}

	Pathtree.prototype.showDetailPanel = function(fd, i)
	{
		if (prepareClick('click', 'show experience detail: ' + fd.getDescription()))
		{
			var panel = $(this).parents(".site-panel")[0];
			var editPanel = new EditExperiencePanel(fd.experience, panel, revealPanelLeft);
												  
			revealPanelLeft(editPanel.node());
			d3.event.stopPropagation();
		}
	}
	
	Pathtree.prototype.showDetailGroup = function(g, fd, duration)
	{
		duration = (duration !== undefined ? duration : 700);
		var _this = this;
		
		this.detailGroup.datum(fd);
		this.detailGroup.selectAll('rect').datum(fd);
		var detailText = this.detailGroup.append('text')
			.attr("width", "100")
			.attr("height", "1")
			.attr('clip-path', 'url(#id_detailClipPath{0})'.format(this.clipID));
			
		var hasEditChevron = fd.experience.typeName == "More Experience" && fd.experience.canWrite();

		var lines = [];
	
		var s;
		s = fd.pickedOrCreatedValue("Offering", "User Entered Offering");
		if (s && s.length > 0 && lines.indexOf(s) < 0)
		{
			var tspan = detailText.append('tspan')
				.style("font-weight", "bold")
				.text(s)
				.attr("x", this.textDetailLeftMargin)
				.attr("dy", 
					function(d) {
						return $(this).height() + _this.detailTextSpacing;
					});
		}
			
		s = fd.pickedOrCreatedValue("Organization", "User Entered Organization");
		if (s && s.length > 0 && lines.indexOf(s) < 0)
		{
			var tspan = detailText.append('tspan')
				.text(s)
				.attr("x", this.textDetailLeftMargin)
				.attr("dy", 
					function(d) {
						return $(this).height() + _this.detailTextSpacing;
					});
		}

		s = fd.pickedOrCreatedValue("Site", "User Entered Site");
		if (s && s.length > 0 && lines.indexOf(s) < 0)
		{
			var tspan = detailText.append('tspan')
				.classed('address-line', true)
				.text(s)
				.attr("x", this.textDetailLeftMargin);
				
			tspan.attr("dy", 
					function(d) {
						return $(this).height() + _this.detailTextSpacing;
					});
		}

		s = getDateRange(fd.experience);
		if (s && s.length > 0)
		{
			var tspan = detailText.append('tspan')
				.text(s)
				.attr("x", this.textDetailLeftMargin);
				
			tspan.attr("dy", 
					function(d) {
						return $(this).height() + _this.detailTextSpacing;
					});
		}
		
		var x = fd.x;
		var y = fd.y;

		var textBox = detailText.node().getBBox();
		
		var iconAreaWidth = (hasEditChevron ? this.showDetailIconWidth + this.textDetailLeftMargin : 0);
		var maxX = $(this.svg.node()).width() - textBox.width - iconAreaWidth - (this.textDetailLeftMargin * 2);
		if (x > maxX)
			x = maxX;
		var rectWidth = textBox.width + iconAreaWidth + (this.textDetailLeftMargin * 2);
		if (rectWidth < this.flagWidth)
		{
			rectWidth = this.flagWidth;
			textBox.width = rectWidth - iconAreaWidth - (this.textDetailLeftMargin * 2);
		}

		s = getMarkerList(fd.experience);
		if (s && s.length > 0)
		{
			var text = d3.select(this),
				words = s.split(/\s+/).reverse(),
				word,
				line = [],
				tspan = detailText.append("tspan").attr("x", this.textDetailLeftMargin).classed('markers', true);
			while (word = words.pop()) {
			  line.push(word);
			  tspan.text(line.join(" "));
			  if (tspan.node().getComputedTextLength() > textBox.width) {
				line.pop();
				tspan.text(line.join(" "));
				tspan.attr("dy", 
					function(d) {
						return $(this).height() + _this.detailTextSpacing;
					});
				line = [word];
				tspan = detailText.append("tspan").attr("x", this.textDetailLeftMargin).classed('markers', true).text(word);
			  }
			}
			tspan.attr("dy", 
				function(d) {
					return $(this).height() + _this.detailTextSpacing;
				});

			textBox = detailText.node().getBBox();
		}

		var rectHeight = textBox.height + (textBox.y * 2);
		var strokeWidth = parseInt($(this.detailFrontRect.node()).css("stroke-width"));
		var maxY = $(this.svg.node()).height() - rectHeight - strokeWidth;
		if (y > maxY)
			y = maxY;
			
		this.detailGroup.attr("x", x)
				 .attr("y", y)
				 .attr("transform", "translate("+x + "," + y+")")
				 .attr("height", 0);
		this.detailGroup.selectAll('rect')
			.attr("width", rectWidth)
		   .attr("x", textBox.x - this.textDetailLeftMargin)
		   .attr("y", 0);
		this.detailFrontRect.each(this.setColor)
					   .each(this.setupServicesTriggers);
		if (duration > 0)
		{
			this.detailGroup.selectAll('rect').attr("height", 0)
					   .transition()
					   .duration(duration)
					   .attr("height", rectHeight);
		}
		else
		{
			this.detailGroup.selectAll('rect').attr("height", rectHeight);
		}
	   
		/* Set the clip path of the text to grow so the text is revealed in parallel */
		var textClipRect = d3.select("#id_detailClipPath{0}".format(this.clipID)).selectAll('rect')
			.attr('x', textBox.x)
			.attr('y', textBox.y)
			.attr('width', textBox.width); 
		
		var iconClipRect;
		
		if (hasEditChevron)
		{	
			iconClipRect = d3.select("#id_detailIconClipPath{0}".format(this.clipID)).selectAll('rect')
				.attr('x', rectWidth - this.showDetailIconWidth - this.textDetailLeftMargin)
				.attr('y', textBox.y)
				.attr('width', this.showDetailIconWidth);
				
			var detailChevron = this.detailGroup.append('image')
				.attr("width", this.showDetailIconWidth)
				.attr("height", this.showDetailIconWidth)
				.attr("xlink:href", rightChevronPath)
				.attr('clip-path', 'url(#id_detailIconClipPath{0})'.format(this.clipID))

			detailChevron.attr('x', rectWidth - this.showDetailIconWidth - this.textDetailLeftMargin)
				.attr('y', textBox.y + (textBox.height - this.showDetailIconWidth) / 2);
		}
			
		if (duration > 0)
		{
			textClipRect.attr('height', 0)
				.transition()
				.duration(duration)
				.attr('height', textBox.height); 
			detailText				
				.transition()
				.duration(duration)
				.attr("height", textBox.height);

			if (hasEditChevron)
				iconClipRect.attr('height', 0)
					.transition()
					.duration(duration)
					.attr('height', textBox.height);
		}
		else
		{
			textClipRect.attr('height', textBox.height); 
			detailText.attr("height", textBox.height);
			if (hasEditChevron)
				iconClipRect.attr('height', textBox.height);
		}
		
		this.detailFlagData = fd;
		this.flagElement = g;
		
		var experience = this.detailFlagData.experience;
		[experience.getCell("Organization"),
		 experience.getCell("User Entered Organization"),
		 experience.getCell("Site"),
		 experience.getCell("User Entered Site"),
		 experience.getCell("Start"),
		 experience.getCell("End"),
		 experience.getCell("Service"),
		 experience.getCell("User Entered Service")].forEach(function(d)
		 {
			/* d will be null if the experience came from the organization for the 
				User Entered Organization and User Entered Site.
			 */
			if (d)
			{
				$(d).on("dataChanged.cr", null, _this, _this.handleChangeDetailGroup);
				$(d).on("valueAdded.cr", null, _this, _this.handleChangeDetailGroup);
			}
		 });
		[experience.getCell("Service"),
		 experience.getCell("User Entered Service")].forEach(function(d)
		 {
			/* d will be null if the experience came from the organization for the 
				User Entered Organization and User Entered Site.
			 */
			if (d)
			{
				$(d).on("valueDeleted.cr", null, _this, _this.handleChangeDetailGroup);
			}
		 });
		 
	}
	
	Pathtree.prototype.handleChangeDetailGroup = function(eventObject, newValue)
	{
		if (!(eventObject.type == "valueAdded" && newValue && newValue.isEmpty()))
			eventObject.data.refreshDetail();
	}
	
	Pathtree.prototype.clearDetail = function()
	{
		this.detailGroup.selectAll('text').remove();
		this.detailGroup.selectAll('rect').attr('height', 0);
		/* Remove the image here instead of when the other clipPath ends
			so that it is sure to be removed when the done method is called. 
		 */
		this.detailGroup.selectAll('image').remove();
		d3.select("#id_detailClipPath{0}".format(this.clipID)).attr('height', 0);
		d3.select("#id_detailIconClipPath{0}".format(this.clipID)).attr('height', 0);
		
		var _this = this;
		if (this.detailFlagData)
		{
			var experience = this.detailFlagData.experience;
			[experience.getCell("Organization"),
			 experience.getCell("User Entered Organization"),
			 experience.getCell("Site"),
			 experience.getCell("User Entered Site"),
			 experience.getCell("Start"),
			 experience.getCell("End"),
			 experience.getCell("Service"),
			 experience.getCell("User Entered Service")].forEach(function(d)
			 {
				/* d will be null if the experience came from the organization for the 
					User Entered Organization and User Entered Site.
				 */
			 	if (d)
			 	{
					$(d).off("dataChanged.cr", null, _this.handleChangeDetailGroup);
					$(d).off("valueAdded.cr", null, _this.handleChangeDetailGroup);
				}
			 });
			[experience.getCell("Service"),
			 experience.getCell("User Entered Service")].forEach(function(d)
			 {
				/* d will be null if the experience came from the organization for the 
					User Entered Organization and User Entered Site.
				 */
				if (d)
				{
					$(d).off("valueDeleted.cr", null, _this.handleChangeDetailGroup);
				}
			 });
			 
			 this.detailFrontRect.each(this.clearServicesTriggers);
			 
		}
		
		this.detailGroup.datum(null);
		this.detailGroup.selectAll('rect').datum(null);
		this.detailFlagData = null;
		this.flagElement = null;
	}

	Pathtree.prototype.hideDetail = function(done, duration)
	{
		duration = (duration !== undefined ? duration : 250);
		
		var _this = this;
		if (this.flagElement != null)
		{
			if (duration === 0)
			{
				this.clearDetail();
				if (done) done();
			}
			else
			{
				d3.select("#id_detailClipPath{0}".format(this.clipID)).selectAll('rect')
					.transition()
					.attr("height", 0)
					.duration(duration)
					.each("end", function() {
						_this.clearDetail();
						if (done)
							done();
					});
				d3.select("#id_detailIconClipPath{0}".format(this.clipID)).selectAll('rect')
					.transition()
					.duration(duration)
					.attr("height", 0);
				this.detailGroup.selectAll('rect')
					.transition()
					.duration(duration)
					.attr("height", 0);
			}
		}
		else if (done)
			done();
	}
	
	Pathtree.prototype.refreshDetail = function()
	{
		var oldFlagData = this.detailFlagData;
		var oldElement = this.flagElement;
		var _this = this;
		this.hideDetail(
			function() { _this.showDetailGroup(oldElement, oldFlagData, 0); },
			0);
	}
	
	/* setup up each group (this) that displays an experience to delete itself if
		the experience is deleted.
	 */
	Pathtree.prototype.setupDelete = function(fd, node) 
	{
		var _this = this;
		var valueDeleted = function(eventObject)
		{
			d3.select(eventObject.data).remove();
			_this.handleValueDeleted(this);
		};
		
		var dataChanged = function(eventObject)
		{
			var g = d3.select(eventObject.data);
			var t = g.selectAll('text');
			t.text(function(d) { return d.getDescription(); })
			fd.width = t.node().getBBox().width + 
						_this.textLeftMargin + _this.textRightMargin;
			g.selectAll('rect').attr("x", 0)
				.attr("y", 0 )
				.attr("width", function(fd) { return fd.width; } )
				.attr("height", function(fd) { return fd.height; });
			_this.checkOfferingCells(this,
				function()
				{
					var allG = _this.experienceGroup.selectAll('g');
					_this.optimize(allG)
				});
		}
		
		$(fd.experience).one("valueDeleted.cr", null, node, valueDeleted);
		$(fd.experience).on("dataChanged.cr", null, node, dataChanged);
		
		$(node).on("remove", null, fd.experience, function()
		{
			$(eventObject.data).off("valueDeleted.cr", null, valueDeleted);
			$(eventObject.data).off("dataChanged.cr", null, dataChanged);
		});
	}
	
	Pathtree.prototype.handleChangeServices = function(eventObject)
	{
		var rect = d3.select(eventObject.data);
		var experience = rect.datum();
		
		Pathtree.prototype.setColor.call(eventObject.data, experience);
	}
	
	Pathtree.prototype.setupServicesTriggers = function(fd)
		{
			var e = fd.experience;
			var serviceCell = e.getCell("Service");
			var userServiceCell = e.getCell("User Entered Service");
			$(serviceCell).on("valueAdded.cr valueDeleted.cr dataChanged.cr", null, this, Pathtree.prototype.handleChangeServices);
			$(userServiceCell).on("valueAdded.cr valueDeleted.cr dataChanged.cr", null, this, Pathtree.prototype.handleChangeServices);
		}
	
	Pathtree.prototype.clearServicesTriggers = function(fd)
		{
			var e = fd.experience;
			var serviceCell = e.getCell("Service");
			var userServiceCell = e.getCell("User Entered Service");
			$(serviceCell).off("valueAdded.cr valueDeleted.cr dataChanged.cr", null, Pathtree.prototype.handleChangeServices);
			$(userServiceCell).off("valueAdded.cr valueDeleted.cr dataChanged.cr", null, Pathtree.prototype.handleChangeServices);
		}
	
	Pathtree.prototype.appendExperiences = function()
	{
		var _this = this;

		this.experienceGroup.selectAll('g').remove();
		var g = this.experienceGroup.selectAll('g')
			.data(this.allExperiences.map(function(e) { return new FlagData(e); }))
			.enter()
			.append('g')
			.each(function(d)
				{
					_this.setupDelete(d, this);
				});
		
		function showDetail(fd, i)
		{
			cr.logRecord('click', 'show detail: ' + fd.getDescription());
			var g = this.parentNode;
			var pathtree = this.pathtree;
			
			pathtree.hideDetail(function() {
					pathtree.showDetailGroup(g, fd); 
				});
		}
		
		/* Set up a clipID that uniquely identifies the clip paths for this Pathtree. */
		this.clipID = Pathtree.prototype.nextClipID;
		Pathtree.prototype.nextClipID += 1;

		g.append('rect')
			.each(function()
				{ this.pathtree = _this; })
			.attr("fill", '#FFFFFF')
			.attr("stroke", '#FFFFFF')
			.attr('x', 0)
			.attr('y', 0);
			
		var handleChangedExperience = function(fd)
		{
			var r = this;
			
			var expChanged = function(eventObject)
			{
				Pathtree.prototype.setColor.call(eventObject.data, fd);
			}
			
			$(fd.experience).on("dataChanged.cr", null, this, expChanged);
			$(this).on("remove", null, fd.experience, function(eventObject)
			{
				$(eventObject.data).off("dataChanged.cr", null, expChanged);
			});
		}

		g.append('rect')
			.each(function()
				{ this.pathtree = _this; })
			.attr("fill-opacity", "0.3")
			.attr("stroke-width", "0")
			.on("click", function() 
				{ 
					d3.event.stopPropagation(); 
				})
			.on("click.cr", showDetail)
			.each(this.setColor)
			.each(handleChangedExperience)
			.each(this.setupServicesTriggers)
			.attr('x', 0)
			.attr('y', 0);
			
		g.append('line')
			.each(this.setColor)
			.each(handleChangedExperience)
			.each(this.setupServicesTriggers)
			.attr('x1', 1)
			.attr('x2', 1)
			.attr('y1', 0)
			.attr('stroke-width', 2);

		/* t is the set of all text nodes. */
		var t = g.append('text')
			.each(function() { this.pathtree = _this; })
			.attr("x", 0)
			.attr("dy", "1.1")
			.attr("transform", "translate({0}, 0)".format(_this.textLeftMargin))
			.text(function(fd) { return fd.getDescription(); })
			.on("click", function() 
				{ 
					d3.event.stopPropagation(); 
				})
			.on("click.cr", showDetail);
	
		/* bbox is used for various height calculations. */
		var bbox;
		if (t.node())
			bbox = t.node().getBBox();
		else
			bbox = {height: 20, y: -18};
			
		this.flagHeight = bbox.height + this.textBottomBorder;
		this.flagY = bbox.y;
		
		var smallBBox;
		t.style('font-size', '10px');
		if (t.node())
			smallBBox = t.node().getBBox();
		else
			smallBBox = {height: 20, y: -18};
		this.smallFlagHeight = smallBBox.height + this.textBottomBorder;
		this.smallFlagY = smallBBox.y;
		t.style('font-size', null);

		this.clearLayout();
		this.checkLayout();
	}
	
	Pathtree.prototype.handleValueDeleted = function(experience)
	{
		var index = this.allExperiences.indexOf(experience);
		if (index >= 0)
			this.allExperiences.splice(index, 1);
		if (experience == this.detailFlagData.experience)
			this.hideDetail(function() { }, 0);
		this.clearLayout();
		this.checkLayout();
	};

	Pathtree.prototype.handleExperienceDateChanged = function(eventObject)
	{
		var _this = eventObject.data;
		_this.setDateRange();
		_this.appendExperiences();
	}
		
	Pathtree.prototype.setupExperienceTriggers = function(experience)
	{
		var _this = this;
		
		var handleDataChanged = function(eventObject)
		{
			var exp = this;
			_this.checkOfferingCells(exp,
				function()
				{
					_this.clearLayout();
					_this.checkLayout();
				});
		}
	
		$(experience).on("dataChanged.cr", null, this, handleDataChanged);
		$(experience.getCell("Start")).on("valueAdded.cr valueDeleted.cr dataChanged.cr", null, this, this.handleExperienceDateChanged);
		$(experience.getCell("End")).on("valueAdded.cr valueDeleted.cr dataChanged.cr", null, this, this.handleExperienceDateChanged);
		
		$(this.sitePanel.node()).on("remove", null, experience, function(eventObject)
		{
			$(eventObject.data).off("dataChanged.cr", null, handleDataChanged);
			$(eventObject.data.getCell("Start")).off("valueAdded.cr valueDeleted.cr dataChanged.cr", null, this.handleExperienceDateChanged);
			$(eventObject.data.getCell("End")).off("valueAdded.cr valueDeleted.cr dataChanged.cr", null, this.handleExperienceDateChanged);
		});
	}
	
	Pathtree.prototype.checkOfferingCells = function(experience, done)
	{
		offering = experience.getValue("Offering");
		if (offering && offering.getValueID() && !offering.isDataLoaded)
		{
			var storedI = crp.getInstance(offering.getValueID());
			if (storedI != null)
			{
				offering.importCells(storedI.cells);
				if (done) done();
			}
			else
			{
				offering.checkCells(undefined, done, asyncFailFunction);
			}
		}
		else
		{
			if (done) done();
		}
	}
	
	Pathtree.prototype.addMoreExperience = function(experience)
	{
		this.checkDateRange(experience);
		experience.typeName = "More Experience";
		
		this.checkOfferingCells(experience);
		
		this.allExperiences.push(experience);
		
		this.setupExperienceTriggers(experience);
		
		this.appendExperiences();
		
		if (this.loadingText)
		{
			this.loadingText.remove();
			this.promptAddText.remove();
			this.loadingText = null;
			this.promptAddText = null;
		}
	}
	
	Pathtree.prototype.handleResize = function()
	{
		var newHeight = this.sitePanel.scrollAreaHeight();
		var pathwayContainer = $(this.pathwayContainer.node());
		$(this.timeContainer.node()).height(newHeight);
		pathwayContainer.height(newHeight);
		pathwayContainer.width(this.sitePanel.scrollAreaWidth() - this.dataLeftMargin);
		
		var svg = $(this.svg.node());
		var isPinnedHeight = (this.isMinHeight && svg.height() > newHeight);
		var isPinnedWidth = (this.isMinHeight && svg.width() > pathwayContainer.width());
		
		if (svg.height() < newHeight ||
			isPinnedHeight ||
			svg.width() != pathwayContainer.width())
		{
			if (svg.height() < newHeight ||
				isPinnedHeight)
			{
				svg.height(newHeight);
				this.scaleDayHeightToSize();
			}
				
			if (svg.width() < pathwayContainer.width() ||
				isPinnedHeight ||
				isPinnedWidth)
				svg.width(pathwayContainer.width());
				
			this.clearLayout();
			this.checkLayout();
		}
	}
	
	Pathtree.prototype.showAllExperiences = function()
	{
		this.setDateRange();
		this.scaleDayHeightToSize();
		
		var _this = this;
		
		var resizeFunction = function()
		{
			_this.handleResize();
		}
	
		var node = this.sitePanel.node();
		this.allExperiences.filter(function(d)
			{
				return d.typeName === "More Experience";
			})
			.forEach(function(d)
			{
				_this.setupExperienceTriggers(d);
			});

		$(this.sitePanel.mainDiv.node()).on("resize.cr", resizeFunction);
	
		this.appendExperiences();
	}
		
	Pathtree.prototype.clear = function()
	{
		$(this).trigger("clear.cr");
		
		d3.select(this.containerDiv).selectAll('div').remove();
		
		this.user = null;
		this.allExperiences = [];
		this.pathwayContainer = null;
		this.timeContainer = null;
		this.svg = null;
		this.svgTime = null;
		this.defs = null;
		this.bg = null;
		this.bgTime = null;
		this.loadingText = null;
		this.promptAddText = null;
		this.experienceGroup = null;
		this.yearGroup = null;
		this.detailGroup = null;
		this.detailFrontRect = null;
		this.detailBackRect = null;
	
		this.detailFlagData = null;
		this.flagElement = null;
		this.flagHeight = 0;
		this.flagWidth = 0;
	
		this.minDate = null;
		this.maxDate = null;
		this.timespan = 0;
		this.isLayoutDirty = true;
		this.isMinHeight = false;
		this.dayHeight = 0;
		this.years = [];
	}
	
	Pathtree.prototype.setUser = function(user, editable)
	{
		if (user.privilege === '_find')
			throw "You do not have permission to see information about {0}".format(user.getDescription());
		if (this.user)
			throw "user has already been set for this pathtree";
			
		var _this = this;
		
		this.user = user;
		editable = (editable !== undefined ? editable : true);
		
		var container = d3.select(this.containerDiv);
		
		this.timeContainer = container.append('div')
			.classed("years", true)
			.style("width", this.dataLeftMargin)
			.style("height", "100%");
		
		this.svgTime = this.timeContainer.append('svg')
			.style("width", this.dataLeftMargin)
			.style("height", "100%");

		this.pathwayContainer = container.append('div')
			.classed("pathway", true)
			.style("width", $(this.containerDiv).width() - this.dataLeftMargin)
			.style("height", "100%");
			
		this.svg = this.pathwayContainer.append('svg')
			.classed("pathway", true)
			.style("width", $(this.containerDiv).width() - this.dataLeftMargin)
			.style("height", "100%");
		
		/* Keep the scrolling of the timeContainer and the pathwayContainer synchronized */
		var timeScroller = function()
			{
				var n = _this.pathwayContainer.node();
				if (this.scrollTop != n.scrollTop)
				{
					$(n).off("scroll", pathwayScroller);
					$(n).one("scroll", pathwayScrollReset);
					n.scrollTop = this.scrollTop;
				}
			}
		var timeScrollReset = function()
			{
				$(this).scroll(timeScroller);
			}
			
		var pathwayScroller = function()
			{
				var n = _this.timeContainer.node();
				if (this.scrollTop != n.scrollTop)
				{
					$(n).off("scroll", timeScroller);
					$(n).one("scroll", timeScrollReset);
					n.scrollTop = this.scrollTop;
				}
			}
		var pathwayScrollReset = function()
			{
				$(this).scroll(pathwayScroller);
			}
			
			
		$(this.timeContainer.node()).scroll(timeScroller);
		$(this.pathwayContainer.node()).scroll(pathwayScroller);

		this.defs = this.svg.append('defs');
	
		/* bg is a rectangle that fills the background with the background color. */
		this.bg = this.svg.append('rect')
			.attr("x", 0).attr("y", 0)
			.style("width", "100%")
			.style("height", "100%")
			.attr("fill", this.pathBackground);
			
		/* bgTime is a rectangle that fills the background of the timeline with the background color. */
		this.bgTime = this.svgTime.append('rect')
			.attr("x", 0).attr("y", 0)
			.style("width", "100%")
			.style("height", "100%")
			.attr("fill", this.pathBackground);
			
		this.loadingMessage = crv.appendLoadingMessage(this.containerDiv)
			.style("position", "absolute")
			.style("left", "0")
			.style("top", "0");
		
		this.experienceGroup = this.svg.append('g')
				.attr("font-family", "San Francisco,Helvetica Neue,Arial,Helvetica,sans-serif")
				.attr("font-size", "1.3rem");
		this.yearGroup = this.svgTime.append('g')
			.attr("fill", "#777");
			
		this.detailGroup = this.svg.append('g')
				.attr("font-family", "San Francisco,Helvetica Neue,Arial,Helvetica,sans-serif")
				.attr("font-size", "1.3rem")
			.style("width", "100%")
			.style("height", "100%")
			.on("click", function(d) 
				{ 
					d3.event.stopPropagation(); 
				})
			.on("click.cr", this.showDetailPanel);
		this.detailBackRect = this.detailGroup.append('rect')
			.attr("fill", this.pathBackground)
			.attr("width", "100%");
		this.detailFrontRect = this.detailGroup.append('rect')
			.attr("fill-opacity", "0.3")
			.attr("stroke-opacity", "0.8")
			.attr("width", "100%");
			
		$(_this.sitePanel.node()).one("revealing.cr", function()
			{
				$(_this.svg.node()).width(_this.sitePanel.scrollAreaWidth() - _this.dataLeftMargin);
			});

		d3.select(this.containerDiv).selectAll('svg')
			.on("click", function() 
			{ 
				d3.event.stopPropagation(); 
			})
			.on("click.cr", function() {
				cr.logRecord('click', 'hide details');
				_this.hideDetail();
			});
		
		var successFunction1 = function(experiences)
		{
			_this.allExperiences = experiences;
			$(experiences).each(function()
			{
				this.typeName = "Experience";
				this.setDescription(this.getValue("Offering").getDescription());
			});
		
			crp.getData({path: "#" + _this.user.getValueID() + '::reference(Experience)::reference(Experiences)' + 
								'::reference(Session)::reference(Sessions)::reference(Offering)',
						 done: function(newInstances)
							{
							},
							fail: asyncFailFunction});
			crp.getData({path: "#" + _this.user.getValueID() + '>"More Experiences">"More Experience">Offering',
						 done: function(newInstances)
							{
							},
							fail: asyncFailFunction});			
			crp.getData({path: "Service", 
						 done: function(newInstances)
							{
							},
							fail: asyncFailFunction});
			crp.getData({path: '"Service Domain"', 
						 done: function(newInstances)
							{
								for (i = 0; i < newInstances.length; ++i)
								{
									if (newInstances[i].getDescription() == "Other")
									{
										color = newInstances[i].getValue("Color");
										if (color && color.text)
											otherColor = color.text;
										break;
									}
								}
							},
						fail: asyncFailFunction});
								
			crp.pushCheckCells(_this.user, undefined, 
				function() {
					var m = _this.user.getValue("More Experiences");
					if (m && m.getValueID())
					{
						m.getCellData("More Experience",
									  successFunction2, 
									  asyncFailFunction);
					}
					else
						successFunction2([]);	/* There are none. */
				},
				function(err)
				{
					asyncHidePanelRight(_this.sitePanel.node());
					asyncFailFunction(err);
				});
		}

		var successFunction2 = function(experiences)
		{
			_this.allExperiences = _this.allExperiences.concat(experiences);
			
			$(experiences).each(function()
			{
				this.typeName = "More Experience";
				this.calculateDescription();
			});
			
			/* Ensure that all of the offerings have their associated cells. */
			_this.allExperiences.forEach(function(experience)
				{
					_this.checkOfferingCells(experience, null);
				});
		
			_this.showAllExperiences();
			
			crv.stopLoadingMessage(_this.loadingMessage);
			_this.loadingMessage.remove();
			
			if (_this.allExperiences.length == 0 && editable)
			{
				_this.loadingText = _this.svg.append('text')
					.attr("x", 0).attr("y", 0)
					.attr("fill", "#777")
					.text('Ready to record an experience?');
				
				_this.loadingText
					.attr("y", _this.loadingText.node().getBBox().height);
			
				var bbox = _this.loadingText.node().getBBox();
				_this.promptAddText = _this.svg.append('text')
					.attr("fill", "#2C55CC")
					.text(" Record one now.")
					.on("click", function(d) {
						if (prepareClick('click', 'Record one now prompt'))
						{
							try
							{
								showClickFeedback(this);
								var newPanel = new NewExperiencePanel(_this, _this.sitePanel.node());
							}
							catch (err)
							{
								syncFailFunction(err);
							}
						}
						d3.event.preventDefault();
					})
					.attr("cursor", "pointer");
				
				var newBBox = _this.promptAddText.node().getBBox();
				if (bbox.x + bbox.width + _this.textLeftMargin + newBBox.width >
					$(_this.bg.node()).width - _this.flagsRightMargin)
				{
					_this.promptAddText.attr("x", _this.loadingText.attr("x"))
						.attr("y", parseFloat(_this.loadingText.attr("y")) + bbox.height);
				}
				else
				{
					_this.promptAddText.attr("x", bbox.x + bbox.width + _this.textLeftMargin)
						.attr("y", _this.loadingText.attr("y"));
				}
			}
			
			$(_this).trigger("userSet.cr");
		}
		
		var path = "#" + this.user.getValueID() + '::reference(Experience)';
		cr.getData({path: path, 
				   fields: ["parents"], 
				   done: successFunction1, 
				   fail: asyncFailFunction});
	}

	function Pathtree(sitePanel, containerDiv) {
		this.containerDiv = containerDiv;
		this.sitePanel = sitePanel;
		this.detailFlagData = null;
		this.flagElement = null;
		this.allExperiences = [];
		
		$(this).on("clear.cr", null, null, function() {
			this.clearDetail();
		});
		
	}
	
	return Pathtree;
})();

var PathtreePanel = (function () {
	PathtreePanel.prototype = new SitePanel();
	PathtreePanel.prototype.pathtree = null;
	
	function PathtreePanel(user, previousPanel, canDone) {
		canDone = canDone !== undefined ? canDone : true;
		var _this = this;

		SitePanel.call(this, previousPanel, null, "My Pathtree", "pathway");
		var navContainer = this.appendNavContainer();
		if (canDone)
		{
			var backButton = navContainer.appendLeftButton()
				.on("click", handleCloseRightEvent);
			backButton.append("span").text("Done");
		}
		
		var addExperienceButton = navContainer.appendRightButton()
			.on("click", function(d) {
				if (prepareClick('click', 'add experience'))
				{
					showClickFeedback(this);
	
					var newPanel = new NewExperiencePanel(_this.pathtree, _this.node());
				}
				d3.event.preventDefault();
			})
			.classed('add-experience-button', true)
			.style("display", "none");
		addExperienceButton.append("span")
			.classed('site-active-text', true)
			.text("+");
		
		navContainer.appendTitle(getUserDescription(user));
		
		var panel2Div = this.appendScrollArea();
		panel2Div.classed('vertical-scrolling', false)
			.classed('no-scrolling', true);

		var bottomNavContainer = this.appendBottomNavContainer();

		var settingsButton = bottomNavContainer.appendLeftButton()
			.on("click", 
				function() {
					if (prepareClick('click', "Settings"))
					{
						var settings = new Settings(user, _this.node());
					}
					d3.event.preventDefault();
				});
		settingsButton.append("i").classed("site-active-text fa fa-lg fa-cog", true);
		settingsButton.style("display", "none");

		var sharingButton = bottomNavContainer.appendLeftButton()
			.on("click", 
				function() {
					if (prepareClick('click', "Sharing"))
					{
						var settings = new SharingPanel(user, _this.node());
					}
		
					d3.event.preventDefault();
				});
		sharingButton.append("i").classed("site-active-text fa fa-lg fa-users", true);
		sharingButton.style("display", "none");
		
		var findButton = bottomNavContainer.appendRightButton()
				.on("click",
					function() {
						if (prepareClick('click', 'find experience'))
						{
							showClickFeedback(this);
							var newPanel = new FindExperiencePanel(cr.signedinUser, null, null, _this.node());
							showPanelLeft(newPanel.node(), unblockClick);
						}
						d3.event.preventDefault();
					});
		findButton.append("i").classed("site-active-text fa fa-lg fa-search", true);
		findButton.style("display", "none");
		
		/* Add buttons that sit on top of the scroll area. */
		this.expandButton = this.panelDiv.append('button')
			.classed('expand', true)
			.on('click', function(d)
				{
					if (prepareClick('click', 'expand'))
					{
						var _thisButton = d3.select(this);
						_thisButton.classed('pressed', true);
						_this.pathtree.scale(1.3,
							function() { _thisButton.classed('pressed', false); unblockClick(); });
						d3.event.preventDefault();
					}
				});
		this.expandButton
			.append('span').text("+");
		this.contractButton = this.panelDiv.append('button')
			.classed('contract', true)
			.on('click', function(d)
				{
					var _thisButton = d3.select(this);
					if (!_thisButton.classed('disabled'))
					{
						if (prepareClick('click', 'contract'))
						{
							_thisButton.classed('pressed', true);
							_this.pathtree.scale(1/1.3,
								function() { _thisButton.classed('pressed', false); unblockClick(); });
							d3.event.preventDefault();
						}
					}
				});
		this.contractButton
			.append('span').text("—");
		
		if (this.pathtree)
			throw "pathtree already assigned to pathtree panel";
			
		this.pathtree = new Pathtree(this, panel2Div.node());
		
		$(this.node()).on("remove", function()
		{
			_this.pathtree.clear();
		});
		
		$(this.pathtree).on("userSet.cr", function()
			{
				var moreExperiences = user.getValue("More Experiences");
				var canAddExperience = (moreExperiences.getValueID() === null ? user.canWrite() : moreExperiences.canWrite());
				addExperienceButton.style("display", canAddExperience ? null : "none");
				settingsButton.style("display", user.privilege === "_administer" ? null : "none");
				sharingButton.style("display", user.privilege === "_administer" ? null : "none");
				findButton.style("display", user.privilege === "_administer" ? null : "none");
			});
	}
	
	return PathtreePanel;
})();

